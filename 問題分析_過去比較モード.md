# 過去比較モードの問題分析

## 問題の理解（確認済み）

ユーザーの理解は**完全に正しい**です。以下の問題が存在します：

### 1. ヘッダー構造
- ✅ ヘッダーは3行で共通している（行0, 1, 2）
- ✅ 行2（3行目）が実際のヘッダー行として使用されている

### 2. ブランドの行位置が異なる
実際のデータを確認：
- **202406**: キリンビバレッジ、アサヒ飲料 コカ・コーラ、その他
- **202506**: リララ、日立 ノクリア、ダイキン うるさら、その他

→ **同じブランド名でも、ファイルによって行番号が異なる**

### 3. 列の位置が異なる
- **202406**: 207列
- **202506**: 195列

→ **調査項目が異なるため、同じ項目名でも列インデックスが異なる可能性がある**

### 4. 現在の実装の問題点

#### 4.1 列マッピング（✅ 問題なし）
`buildColumnMapping`メソッドは、各ファイルごとにヘッダー行から列インデックスを動的にマッピングしているため、列の位置が異なっても対応できています。

```typescript
// 各ファイルごとに独立してマッピングを構築
headers.forEach((header: any, idx: number) => {
  if (headerStr === FUNNEL_LABELS[key]) {
    funnel[key] = idx;  // ファイルごとに異なるインデックスでもOK
  }
});
```

#### 4.2 ブランド名による行検索（✅ 問題なし）
ブランド名は列3（D列）固定で、行をループしてブランド名で検索しているため、行位置が異なっても対応できています。

```typescript
for (let i = EXCEL_STRUCTURE.DATA_START_INDEX; i < jsonData.length; i++) {
  const brandName = row[EXCEL_STRUCTURE.BRAND_NAME_COLUMN];  // 列3固定
  if (!brandName || typeof brandName !== 'string') continue;
  brands[brandName] = metrics;  // ブランド名をキーに保存
}
```

#### 4.3 ブランドイメージ項目の抽出（✅ 解決済み）
`extractBrandImageItems`メソッドは、**パターンマッチング**を使用するように改良されました：

```246:291:src/services/excelParser/ExcelParser.ts
  private extractBrandImageItems(
    categoryRow: any[],
    itemRow: any[],
    headerRow: any[]
  ): BrandImageItem[] {
    const items: BrandImageItem[] = [];

    // 行1（2行目）に「ブランドイメージ」を含む列を検索
    itemRow.forEach((itemName: any, colIdx: number) => {
      if (!itemName || typeof itemName !== 'string') return;

      const itemStr = itemName.trim();
      
      // 「ブランドイメージ」を含むかチェック
      const isBrandImage = BRAND_IMAGE.PATTERNS.ITEM_KEYWORDS.some(keyword =>
        itemStr.includes(keyword)
      );

      if (!isBrandImage) return;

      // 除外キーワードチェック
      const shouldExclude = BRAND_IMAGE.EXCLUDE_KEYWORDS.some((keyword) =>
        itemStr.includes(keyword)
      );
      if (shouldExclude) return;

      // ヘッダー行（行2）から実際の項目名を取得
      const headerName = headerRow[colIdx];
      if (!headerName || typeof headerName !== 'string') {
        // ヘッダー名がない場合は、項目名を使用
        items.push({
          name: itemStr,
          columnIndex: colIdx,
        });
        return;
      }

      items.push({
        name: headerName.trim(),
        columnIndex: colIdx,
      });
    });

    console.log(`[ExcelParser] Extracted ${items.length} brand image items using pattern matching`);
    return items;
  }
```

**解決済み**:
- ✅ 固定範囲ではなく、パターンマッチングで抽出するように変更
- ✅ 行1（項目名行）に「ブランドイメージ」を含む列を動的に検索
- ✅ ファイルによって列数が異なっても自動的に対応可能
- ✅ 各ファイルごとに独立して実行されるため、列位置が異なっても問題なし

### 5. 実際の問題が発生する可能性がある箇所

#### 5.1 ブランドイメージ項目の列範囲（✅ 解決済み）
~~現在の実装では、ブランドイメージ項目は固定範囲（列41-175）から抽出されています。もし：~~
- ~~ファイルによってブランドイメージ項目の開始位置が異なる~~
- ~~ファイルによってブランドイメージ項目の数が異なる~~

~~場合、一部の項目が取得できない、または不要な項目が含まれる可能性があります。~~

**解決済み**: パターンマッチングによる動的抽出に変更され、列位置に依存しない実装になりました。

#### 5.2 過去比較モードでのデータ参照
過去比較モードでは、各データソースから以下のようにデータを取得しています：

```typescript
const brandData = segmentData[selectedBrand];
const value = brandData[key as keyof AllMetrics];
```

これは**ブランド名とメトリクスキー**でデータを取得しているため、行位置や列位置に依存していません。したがって、この部分は問題ありません。

### 6. 結論

**ユーザーの理解は正しく、実装も正しく動作しています。** ✅

主な改善点は既に実装済みです：

1. **ブランドイメージ項目の抽出方法** ✅ **実装完了**
   - ✅ 固定範囲ではなく、ヘッダー名のパターンマッチングで抽出するように変更
   - ✅ 各ファイルごとに動的に列を検出する実装に変更

2. **メトリクス項目の存在確認** 🔄 **検討中**
   - ファイルによって存在しないメトリクス項目がある場合、0を返すのではなく、明示的に「データなし」を表示する

3. **エラーハンドリング** ✅ **実装済み**
   - ✅ ブランドが見つからない場合、列が見つからない場合のエラーメッセージが実装済み

### 7. 推奨される改善策

1. **ブランドイメージ項目の動的検出** ✅ **実装完了**
   - ✅ 固定範囲ではなく、パターンマッチングで抽出するように変更
   - ✅ 行1（項目名行）に「ブランドイメージ」を含む列を動的に検索
   - ✅ ヘッダー名のパターンで抽出

2. **メトリクス項目の存在確認** 🔄 **検討中**
   - 各ファイルごとに存在するメトリクス項目を記録
   - 存在しない項目については、明示的に「データなし」を表示

3. **データ整合性チェック** 🔄 **検討中**
   - 複数ファイルを読み込む際、共通のブランドや項目が存在するかチェック
   - 存在しない場合は警告を表示

